import { Global, Inject, Injectable, OnModuleInit } from '@nestjs/common';
import { Web3Service } from '@lib/common/web3/Web3.service';
import * as path from 'path';
import { WinstonLoggerService } from '@lib/common/logger/WinstonLogger.service';
import { ShutdownService } from '@lib/common/shutdown/Shutdown.service';
import { FSService } from '@lib/common/fs/FS.service';
import { GlobalConfigService } from '@lib/common/globalconfig/GlobalConfig.service';
import EventEmitter from 'events';

/**
 * Build option for the Contracts Service
 */
export interface ContractsServiceOptions {
    /**
     * Filesystem path to the contract artifacts
     */
    artifact_path: string;
}

/**
 * Type of AbiItem
 */
export type AbiType = 'function' | 'constructor' | 'event' | 'fallback';
/**
 * State mutability type of the AbiItem
 */
export type StateMutabilityType = 'pure' | 'view' | 'nonpayable' | 'payable';

/**
 * AbiItem compsing the global Abi
 */
export interface AbiItem {
    /**
     * True if anonymous item
     */
    anonymous?: boolean;

    /**
     * True if constant item
     */
    constant?: boolean;

    /**
     * Inputs of the AbiItem
     */
    inputs?: AbiInput[];

    /**
     * Name of the AbiItem
     */
    name?: string;

    /**
     * Outputs of the AbiItem
     */
    outputs?: AbiOutput[];

    /**
     * True if payable AbiItem
     */
    payable?: boolean;

    /**
     * State mutability type of the item
     */
    stateMutability?: StateMutabilityType;

    /**
     * Type of the AbiItem
     */
    type: AbiType;
}

/**
 * Input of an AbiItem
 */
export interface AbiInput {
    /**
     * Name of input argument
     */
    name: string;

    /**
     * Type of input argument
     */
    type: string;

    /**
     * True if indexed argument
     */
    indexed?: boolean;

    /**
     * Input components
     */
    components?: AbiInput[];
}

/**
 * Output of an AbiItem
 */
export interface AbiOutput {
    /**
     * Name of output argument
     */
    name: string;

    /**
     * Tyoe if output argument
     */
    type: string;

    /**
     * Output components
     */
    components?: AbiOutput[];

    /**
     * Internal type of the output item
     */
    internalType?: string;
}

/**
 * Links of the Contract
 */
export interface ContractLink {
    /**
     * Link address
     */
    address: string;

    /**
     * Events of the Link
     */
    events: string;
}

/**
 * Network information
 */
export interface NetworkInfo {
    /**
     * Address of contract instance
     */
    address: string;

    /**
     * Events emittable by the contract
     */
    events: {
        [key: string]: AbiOutput;
    };

    /**
     * Links of the Contract
     */
    links: ContractLink[];

    /**
     * Deployment transaction hash
     */
    transactionHash: string;
}

/**
 * Compiler information
 */
export interface CompilerInfo {
    /**
     * Name of used compiler
     */
    name: string;

    /**
     * Version used
     */
    version: string;
}

/**
 * Contract Artifact generated by truffle
 */
export interface ContractArtifact {
    /**
     * Name of the Contract
     */
    contractName: string;

    /**
     * Complete contract abi
     */
    abi: AbiItem[] | AbiItem;

    /**
     * Contract metadata
     */
    metadata: string;

    /**
     * Contract deployment bytecode
     */
    bytecode: string;

    /**
     * Contract runtime bytecode
     */
    deployedBytecode: string;

    /**
     * Contract deployment source map
     */
    sourceMap: string;

    /**
     * Contract runtime source map
     */
    deployedSourceMap: string;

    /**
     * Source of the contract
     */
    source: string;

    /**
     * Path of source file
     */
    sourcePath: string;

    /**
     * AST of the contract
     */
    ast: any;

    /**
     * Legacy AST of the contract
     */
    legacyAST: any;

    /**
     * Compiler information
     */
    compiler: CompilerInfo;

    /**
     * Networks information
     */
    networks: {
        [key: number]: NetworkInfo;
    };

    /**
     * Version of the artifact schema
     */
    schemaVersion: string;

    /**
     * Last update timestamp
     */
    updatedAt: string;

    /**
     * Dev documentation
     */
    devdoc: any;

    /**
     * User documentation
     */
    userdoc: any;

    /**
     * Name of containing module
     */
    moduleName: string;
}

/**
 * Contracts Artifacts collection
 */
export interface Contracts {
    [key: string]: ContractArtifact;
}

/**
 * Service to load all contract artifacts from specific path
 */
@Global()
@Injectable()
export class ContractsService implements OnModuleInit {
    /**
     * Dependency Injection
     *
     * @param options
     * @param web3Service
     * @param winstonLoggerService
     * @param shutdownService
     * @param fsService
     * @param globalConfigService
     */
    constructor(
        @Inject('CONTRACTS_MODULE_OPTIONS')
        private readonly options: ContractsServiceOptions,
        private readonly web3Service: Web3Service,
        private readonly winstonLoggerService: WinstonLoggerService,
        private readonly shutdownService: ShutdownService,
        private readonly fsService: FSService,
        private readonly globalConfigService: GlobalConfigService,
    ) {}

    /**
     * Stores all the contract artifacts
     */
    private contracts: Contracts = null;

    /**
     * Utility to verify on-chain code vs artifact code
     *
     * @param networkId
     */
    private async verifyContracts(networkId: number): Promise<void> {
        const web3 = this.web3Service.get();
        for (const contract of Object.keys(this.contracts)) {
            if (!this.contracts[contract].networks[networkId]) {
                continue;
            }
            const address = this.contracts[contract].networks[networkId].address;
            const code = (await web3.eth.getCode(address)).toLowerCase();
            const registeredCode = this.contracts[contract].deployedBytecode.toLowerCase();
            if (code !== registeredCode) {
                const error = new Error(
                    `Failed contract instance verification for ${contract}: network and artifact code do not match !`,
                );
                this.shutdownService.shutdownWithError(error);
                throw error;
            }
            this.winstonLoggerService.log(`Contract instance ${contract} matches on-chain code`);
        }
    }

    /**
     * Utility to load artifact from filesystem
     *
     * @param networkId
     */
    private loadContracts(networkId: number): void {
        try {
            this.contracts = {};
            const artifactContent: string[] = this.fsService.readDir(this.options.artifact_path);
            for (const artifact of artifactContent) {
                if (!this.fsService.isDir(path.join(this.options.artifact_path, artifact))) {
                    continue;
                }

                const contractsModuleDir = path.join(this.options.artifact_path, artifact, 'build', 'contracts');
                const contractsModuleContent = this.fsService.readDir(contractsModuleDir);

                for (const contract of contractsModuleContent) {
                    const contractData: ContractArtifact = JSON.parse(
                        this.fsService.readFile(path.join(contractsModuleDir, contract)),
                    );
                    contractData.moduleName = artifact;
                    const contractName = contract
                        .split('.')
                        .slice(0, -1)
                        .join('.');
                    this.winstonLoggerService.log(`Imported contract instance ${artifact}::${contractName}`);
                    this.contracts[`${artifact}::${contractName}`] = contractData;
                }
            }
        } catch (e) {
            this.shutdownService.shutdownWithError(e);
            throw e;
        }
    }

    /**
     * Utility to load all available artifacts from given path
     */
    private async loadArtifacts(): Promise<Contracts> {
        if (!this.eventEmitter) {
            this.eventEmitter = new EventEmitter.EventEmitter();

            try {
                const networkId: number = await this.web3Service.net();
                this.winstonLoggerService.log(`Starting contract instances import`);
                this.loadContracts(networkId);
                this.winstonLoggerService.log(`Finished contract instances import`);
                this.winstonLoggerService.log(`Starting contract instances verification`);
                await this.verifyContracts(networkId);
                this.winstonLoggerService.log(`Finished contract instances verification`);
                this.eventEmitter.emit('contracts', this.contracts, null);
            } catch (e) {
                this.eventEmitter.emit('contracts', null, e);
                throw e;
            }

            return this.contracts;
        } else {
            return new Promise((ok: any, ko: any): void => {
                this.eventEmitter.on(`contracts`, (contracts: Contracts, error: any): void => {
                    if (error) {
                        return ko(error);
                    }
                    ok(contracts);
                });
            });
        }
    }

    /**
     * Utility to recover artifacts
     */
    public async getContractArtifacts(): Promise<Contracts> {
        return this.contracts || this.loadArtifacts();
    }

    /**
     * Event Emitter used when multiple initialization are occuring at the same time
     */
    private eventEmitter: EventEmitter.EventEmitter = null;

    /**
     * Checks if processed_block_number is set, if not it
     */
    public async onModuleInit(): Promise<void> {
        const globalConfigRes = await this.globalConfigService.search({
            id: 'global',
        });

        if (globalConfigRes.error || globalConfigRes.response.length === 0) {
            const error = new Error(
                `ContractsService::onModuleInit | error while fetching global config: ${globalConfigRes.error ||
                    'no initial config'}`,
            );
            this.shutdownService.shutdownWithError(error);
            throw error;
        }

        const globalConfig = globalConfigRes.response[0];

        if (globalConfig.processed_block_number === 0) {
            this.winstonLoggerService.log(
                `Running artifacts analysis to find the first block from which EVM Events should be fetched`,
            );

            const artifacts = await this.getContractArtifacts();
            const networkId: number = await this.web3Service.net();
            const web3: any = await this.web3Service.get();
            let currentLowestBN: number = await web3.eth.getBlockNumber();

            for (const artifact of Object.keys(artifacts)) {
                if (artifacts[artifact].networks[networkId]) {
                    const txHash = artifacts[artifact].networks[networkId].transactionHash;
                    const deploymentBN = (await web3.eth.getTransaction(txHash)).blockNumber;

                    this.winstonLoggerService.log(`${artifact} was deployed at block number #${deploymentBN}`);
                    if (deploymentBN < currentLowestBN) {
                        this.winstonLoggerService.log(`${artifact} is currently the lowest fetchable entity`);
                        currentLowestBN = deploymentBN;
                    }
                }
            }

            this.winstonLoggerService.log(`The new processed_block_number value is ${currentLowestBN}`);

            const res = await this.globalConfigService.update(
                {
                    id: 'global',
                },
                {
                    processed_block_number: currentLowestBN,
                },
            );

            if (res.error) {
                const error = new Error(
                    `ContractsService::onModuleInit | error while updating global config: ${res.error}`,
                );
                this.shutdownService.shutdownWithError(error);
                throw error;
            }
        }
    }
}
